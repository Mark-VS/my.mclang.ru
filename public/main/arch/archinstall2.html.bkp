<!DOCTYPE html>
<html lang="RU">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>archinstall2</title>
    <link rel="stylesheet" href="/assets/styles/style.css">
    <link rel="stylesheet" href="/assets/highlight/styles_custom/androidstudio.css">
</head>
<body>
<script src="/assets/highlight/highlight.min.js"></script>
<a href="/arch">Вернуться назад</a>

<h1>дддддд</h1>

<h2>1. vconsole</h2>

<pre><code class="language-bash"># Файлы с раскладками:
/usr/share/kbd/keymaps/i386/qwerty/

# Файлы со шрифтами:
/usr/share/kbd/consolefonts/

# Посмотреть список раскладок:
localectl list-keymaps
# или:
ls /usr/share/kbd/keymaps/i386/qwerty/

# Загрузить русскую раскладку
loadkeys ru
   # эта раскладка переключается сочетанием клавиш Ctrl+Shift

# Загрузить обратно английскую раскладку:
loadkeys us

# Дефолтная раскладка:
loadkeys defkeymap

# Установить шрифт с поддержкой  русского языка:
setfont cyr-sun16

setfont LatArCyrHeb-16
setfont LatArCyrHeb-16+
setfont LatArCyrHeb-19
setfont latarcyrheb-sun16
setfont latarcyrheb-sun32
</code></pre>

<h4>Посмотреть, какой файл раскладки загружается</h4>
<pre><code class="language-bash"># Вывести первые 10 записей:
sudo loadkeys -v en 2>&1 | head -n 10
   # Загружается /usr/share/kbd/keymaps/pine/en.map.gz
   # переключение на linux-keys-bare
   # предполагается iso-8859-15 euro
   # код клавиши 1, таблица 0 = 27
   # ...

   # аргумент -v выводит инфу в std:err, поэтому нам надо перенаправить его в std:out
</code></pre>

<p>Пример конфигурационного файла:</p>
<pre><code class="language-bash"># /etc/vconsole.conf:

KEYMAP=ru
FONT=cyr-sun16
</code></pre>

<p>Или вот русская раскладка, которая переключается через ALT+SHIFT:</p>
<pre><code class="language-bash"># /etc/vconsole.conf:

KEYMAP=ruwin_alt_sh-UTF-8
FONT=cyr-sun16
</code></pre>

<p>Если мы хотим, чтобы конфигурационный файл применился, надо либо перезагрузить систему, либо выполнить:</p>
<pre><code class="language-bash">sudo systemctl restart systemd-vconsole-setup.service</code></pre>


<p>Когда мы выполняем команду <strong><i>loadkeys ru</i></strong>, это подгружает файл <strong><i>/usr/share/kbd/keymaps/i386/qwerty/ru.map.gz</i></strong></p>
<p><strong><i>loadkeys us</i></strong> подгружает <strong><i>/usr/share/kbd/keymaps/i386/qwerty/us.map.gz</i></strong>.</p>
<p><strong><i>loadkeys ruwin_alt_sh-UTF-8</i></strong> подгружает <strong><i>/usr/share/kbd/keymaps/i386/qwerty/ruwin_alt_sh-UTF-8</i></strong></p>

<p>А вот <strong><i>loadkeys en</i></strong> подгружает файл <strong><i>/usr/share/kbd/keymaps/pine/en.map.gz</i></strong>.</p>


<!--- !!! --- ЛОКАЛЬ --- !!! -->

<h2>2. Локаль</h2>

<p>Все работающие в данный момент локали находятся внутри бинарного файла <strong><i>/usr/lib/locale/locale-archive</i></strong>. Если я хочу посмотреть список этих локалей, то могу это сделать вот так:</p>
<pre><code class="language-bash">locale -a
  # C
  # C.utf8
  # POSIX
</code></pre>
<p style="margin-bottom: 6px">Если я хочу добавить в систему ещё какие-нибудь локали, то мне нужно сгенерировать их из шаблонов, которые находятся в папке <strong><i>/usr/share/i18n/</i></strong>. То есть добавить их из этих шаблонов внутрь файла <strong><i>/usr/lib/locale/locale-archive</i></strong>. Как это сделать? С помощью <strong><i>locale-gen</i></strong>.</p>
<p style="margin-top: 0; margin-bottom: 6px">Список доступных для генерации локалей я могу посмотреть в файле <strong><i>/usr/share/i18n/SUPPORTED</i></strong>:</p>
<pre style="margin-top: 0"><code class="language-bash">cat /usr/share/i18n/SUPPORTED | grep less</code></pre>

<p style="margin-top: 4px; margin-bottom: 4px">Я хочу добавить себе две локали:</p>
<ul style="margin-top: 0; margin-bottom: 0">
  <li>en_US.UTF-8 UTF-8</li>
  <li>ru_RU.UTF-8 UTF-8</li>
</ul>
<p style="margin-top: 4px; margin-bottom: 8px">Я их так и записываю в файл <strong><i>/etc/locale.gen</i></strong>. То есть, в этом файле я указываю, какие локали хочу сгенерировать.</p>
<pre style="margin-top: 0"><code class="language-bash"># /etc/locale.gen

en_US.UTF-8 UTF-8
ru_RU.UTF-8 UTF-8
</code></pre>

<p>И далее я запускаю команду:</p>
<pre><code class="language-bash">locale-gen</code></pre>
<p>Эта команда смотрит в файл <strong><i>/etc/locale.gen</i></strong> и видит, что я хочу сгенерировать две новые локали. Она находит их исходники в папке <strong><i>/usr/share/i18n/</i></strong> и на их основе создаёт две новые локали и дабавляет их внуть файла <strong><i>/usr/lib/locale/locale-archive</i></strong>.</p>

<p>Теперь я снова проверяю список работающих в системе локалей и вижу, что там появились две новые: <strong><i>en_US.utf8</i></strong> и <strong><i>ru_RU.utf8</i></strong>:</p>
<pre><code class="language-bash">locale -a
  # C
  # C.utf8
  # en_US.utf8
  # POSIX
  # ru_RU.utf8
</code></pre>

<p>Так как у меня теперь несколько локалей, неплохо бы указать системе, какую из них я хочу использовать по умолчанию. Это делается в файле <strong><i>/etc/locale.conf</i></strong>:</p>
<pre><code class="language-bash"># /etc/locale.conf

LANG=ru_RU.UTF-8</code></pre>
<p>Либо можно запустить команду, которая прописывает локаль в файл <strong><i>/etc/locale.conf</i></strong>:</p>
<pre><code class="language-bash">sudo localectl set-locale LANG=ru_RU.UTF-8</code></pre>

<p>Всё. Готово. Я сгенерировал две локали: <strong><i>en_US.UTF-8</i></strong> и <strong><i>ru_RU.UTF-8</i></strong> и добавил вторую из них как системную по умолчанию.</p>

<p>Посмотреть список переменных локали:</p>
<pre><code class="language-bash">locale</code></pre>

<p style="margin-bottom: 6px">Локали в <strong><i>/usr/share/i18n/</i></strong> поставляются вместе с библиотекой <strong><i>glibc</i></strong>. При установке <strong><i>glibc</i></strong> он создаёт структуру каталогов, где лежат исходные данные для генерации локалей:</p>
<ul style="margin-top: 0; margin-bottom: 0">
   <li>/usr/share/i18n/ – общий каталог международных данных</li>
   <li>/usr/share/i18n/locales/ – описания локалей</li>
   <li>/usr/share/i18n/charmaps/ – таблицы кодировок</li>
   <li>/usr/share/i18n/SUPPORTED – список всех локалей, которые поддерживает glibc</li>
</ul>
<p style="margin-top: 6px">А <strong><i>glibc</i></strong> ставится в систему автоматически при установке метапакета <strong><i>base</i></strong>.</p>



<!-- !!! --- EFI или не EFI --- !!! -->

<h2>3. EFI или MBR</h2>
<p>Проверим режим загрузки, чтобы узнать у нас стоит BIOS или UEFI:</p>
<pre><code class="language-bash">cat /sys/firmware/efi/fw_platform_size
# Если исп. режим BIOS, то никакой инфы не вылезет. А если исп. UEFI, то получим либо 64, либо 32
</code></pre>



<!-- !!! --- РАЗМЕТКА ЖЁСТКОГО ДИСКА --- !!! -->

<h2>4. Разметка жёсткого диска</h2>

<p>Посмотреть типы таблицы существующих разделов (Partition Table Type):</p>
<pre><code class="language-bash"># Здесь столбец PTTYPE покажет тип:
lsblk -o NAME,SIZE,TYPE,PTTYPE /dev/sda

# Или вот так:
sudo fdisk -l /dev/sda
    # ...
    # Тип метки диска: gpt  // Disklabel type: dos

# Или:
sudo parted /dev/sda print
    # ...
    # Таблица разделов: gpt // Partition Table: gpt

# Или:
sudo blkid /dev/sda
    # /dev/sda: PTUUID="e3398c6a-9208-40eb-b2db-c4cbb82a8df7" PTTYPE="gpt"

# То же самое, но развёрнуто:
sudo blkid -s PTUUID -s PTTYPE /dev/sda
    # /dev/sda: PTUUID="e3398c6a-9208-40eb-b2db-c4cbb82a8df7" PTTYPE="gpt"

# Вывести только значение:
sudo blkid -s PTTYPE -o value /dev/sda
    # gpt
</code></pre>

<p style="margin-bottom: 4px">У меня SSD на 512 GB. Я хочу разбить его на 4 рездела:</p>
<ul style="margin-top: 0">
    <li>UEFI – 512 MB</li>
    <li>swap – 16 GB</li>
    <li>root – 80 GB</li>
    <li>home – ≈415 GB</li>
</ul>

<h3>fdisk</h3>
<pre><code class="langauge-bash">
fdisk /dev/sda
 → p – посмотреть список существующих разделов
# Создаём метку gpt для таблицы разделов:
  → g
# Создаём 4 рездела:
  → n → +512M
  → n → +16G
  → n → +80G
  → n → Enter
# Тип раздела:
  → t → 1 → 1  (EFI System)
  → t → 2 → 19 (Linux Swap)
  → t → 3 → 20 (Linux System)
  → t → 4 → 20 (Linux System)

# Ещё раз выводим разделы, чтобы убедиться, что всё в порядке:
  → p
# Применяем изменения:
  → w
</code></pre>

<p>Готово. Разделы созданы. Убедимся в этом:</p>
<pre><code class="language-bash">lsblk /dev/sda

# более подробный вывод:
lsblk -f /dev/sda
</code></pre>

<h3>parted</h3>
<p>Каждому GPT-разделу можно присвоить имя для удобства. Или его ещё называют GPT-метка. В программе <strong><i>fdisk</i></strong> этого сделать нельзя. Но это можно сделать через <strong><i>parted</i></strong>.</p>

<pre><code class="language-bash">
parted /dev/sda
  name → номер_раздела → имя_раздела

# Создадим имена для наших разделов:
  name → 1 → UEFIPart
  name → 2 → SwapPart
  name → 3 → RootPart
  name → 4 → HomePart

# Посмотреть список разделов:
  print
    # у каждого раздела появилось имя

# В отличие от fdisk, тут не нужно сохранять изменения перед выходом из программы.
# Изменения применяются сразу во время работы с parted.

# Выйти из parted:
  quit
</code></pre>

<p>Посмотреть список разделов и их имена одной командой:</p>
<pre><code class="language-bash">parted /dev/sda print</code></pre>

<p>Можно посмотреть всю информацию о том, что мы сейчас сделали, через <strong><i>lsblk</i></strong>.</p>
<pre><code class="language-bash"># Здесь мы явно указываем имена столбцов:

lsblk -o NAME,PTTYPE,FSTYPE,LABEL,PARTLABEL,UUID /dev/sda
  # NAME – имя устройства
  # PTTYPE – тип таблицы разделов (gpt/dos)
  # FSTYPE – файловая система
  # LABEL – метка файловой системы
  # PARTLABEL – имя GPT-раздела
  # UUID – имя/идентификатор GPT-раздела
</code></pre>



<!-- !!! --- ФОРМАТИРОВАНИЕ РАЗДЕЛОВ --- !!! -->


<h2>5. Форматирование разделов</h2>
<pre><code class="language-bash">
# Форматирование разделов:
mkfs.fat -F 32 /dev/sda1    # Форматируем в FAT32
   # mkfs.vfat /dev/sda1    # То же самое
mkswap /dev/sda2            # Создаём swap-раздел
mkfs.ext4 /dev/sda3         # Форматируем в ext4
mkfs.ext4 /dev/sda4         # Форматируем в ext4

# Форматирование и создание метки одновременно:
mkfs.fat -F 32 -n EFILABEL /dev/sda1    # Форматируем в FAT32
   # mkfs.vfat -n EFILABEL /dev/sda1    # То же самое
mkswap -L SwapLabel /dev/sda2           # Создаём swap-раздел
mkfs.ext4 -L RootLabel /dev/sda3        # Форматируем раздел в ext4
mkfs.ext4 -L HomeLabel /dev/sda4        # Форматируем раздел в ext4

# Создать метку для уже отформатированных разделов:
fatlabel /dev/sda1 NEWLABEL     # для FAT32
tune2fs -L NewLabel /dev/sda3   # для ext4
e2label /dev/sda4 NewLabel      # для ext4
mkswap -L NewLabel /dev/sda2    # для swap-раздела
</code></pre>

<h2>wipefs</h2>

<pre><code class="language-bash"># Сначала удаляет сигнатуры на всех разделах
wipefs -a /dev/sda1
wipefs -a /dev/sda2
wipefs -a /dev/sda3
wipefs -a /dev/sda4

# А затем на всём диске:
wipefs -a /dev/sda
</code></pre>



<!-- !!! --- МОНТИРОВАНИЕ ФАЙЛОВОЙ СИСТЕМЫ --- !!! -->


<h2>6. Монтирование файловой системы</h2>

<pre><code class="language-bash">
mount /dev/sda3 /mnt            # монтируем корень системы
mkdir -p /mnt/boot/efi          # создаём папку под EFI-раздел
mount /dev/sda1 /mnt/boot/efi   # монтируем EFI-раздел
mkdir -p /mnt/home              # создаём папку для раздела home
mount /dev/sda4 /mnt/home       # монтируем home
swapon /dev/sda2                # включаем раздел подкачки
</code></pre>

<pre><code class="language-bash">mkdir -pv /mnt/{proc,dev,sys,run}

mount -t proc /proc /mnt/proc
mount --rbind /dev /mnt/dev
mount --rbind /sys /mnt/sys
mount --rbind /run /mnt/run   # я устанавливал и не монтируя этот раздел

mount --make-rslave /mnt/dev   # не обязательно
mount --make-rslave /mnt/sys   # не обязательно
mount --make-rslave /mnt/run   # не обязательно
</code></pre>

<h3>Что ещё нужно перед установкой базовых пакетов</h3>
<pre><code class="language-bash">
# Этот каталог нужен pacman'у:
mkdir -p /mnt/var/lib/pacman
   # Если мы его не создадим, то pacman не будет ставить пакеты в новую систему –
   # он будет ругаться на отсутствие этой папки.

# Ещё нам обязательно понадобится файл (хотя бы пустой):
/etc/vconsole.conf
   # Без него initramfs не соберётся,
   # pacman просто выдаст ошибку во время установки
</code></pre>


<p>Перед тем, как устанавливать базовые пакеты, нужно иметь понятие о том, куда они будут скачиваться во время установки. Это важно, потому что если мы загрузились с флэшки, на которой мало места, то по умолчанию pacman будет скачивать пакеты на неё, но из-за нехватики места пакеты не скачаются и не установятся. Чтобы проверить, куда они скачиваются во время установки, можно ввести команду:</p>
<pre><code class="language-bash">pacman -v

# Root      : /
# Conf File : /etc/pacman.conf
# DB Path   : /var/lib/pacman/
# Cache Dirs: /var/cache/pacman/pkg/  
# Hook Dirs : /usr/share/libalpm/hooks/  /etc/pacman.d/hooks/  
# Lock File : /var/lib/pacman/db.lck
# Log File  : /var/log/pacman.log
# GPG Dir   : /etc/pacman.d/gnupg/
# Targets   : Нет
</code></pre>

<p><strong><i>Cache Dirs</i></strong> – это и есть папка, куда скачиваются пакеты из репозитория Arch перед установкой. То есть они будут скачиваться на флэшку, с которой мы загрузились. Но нам надо указать папку на SSD, в которую мы устанавливаем Arch, т.е. <strong><i>/mnt/var/cache/pacman/pkg</i></strong>. Укажем этот каталог во время установки базовых пакетов:</p>

<h3>Установка базовых пакетов</h3>
<pre><code class="language-bash">pacman -r /mnt --cachedir=/mnt/var/cache/pacman/pkg -Sy base linux linux-firmware
</code></pre>


<pre><code class="language-bash">
genfstab -L /mnt >> /mnt/etc/fstab
</code></pre>


<h2>7. chroot</h2>

<pre><code class="language-bash">chroot /mnt /bin/bash
source /etc/profile
export PS1="(arch-chroot) \u:\w\$ "
</code></pre>

<h3>pacman, репозитории, ключи</h3>

<p>У нас должна была сохраниться рабочая сеть от системы хоста.</p>

<p>Чтобы <strong><i>pacman</i></strong> мог скачивать пакеты из репозиториев, нужно ему указать зеркала с доступными репозиториями в файле <strong><i>/etc/pacman.d/mirrorlist</i></strong>. Во время установки пакета <strong><i>base</i></strong> этот файл должен был сгенерироваться автоматически, но все строки в нём закомментированы. Нам надо раскомментировать ближайшие к нам репозитории. Содержание файла должно быть примерно таким:</p>

<pre><code class="language-bash"># /etc/pacman.d/mirrorlist

Server = https://at.arch.niranjan.co/$repo/os/$arch
Server = https://de.arch.niranjan.co/$repo/os/$arch
Server = https://berlin.mirror.pkgbuild.com/$repo/os/$arch
Server = https://al.arch.niranjan.co/$repo/os/$arch
Server = https://ro.arch.niranjan.co/$repo/os/$arch
Server = https://mirror.5i.fi/archlinux/$repo/os/$arch
...
</code></pre>

<p>Следующее, что нам нужно сделать, это обновить ключи, ведь иначе pacman не будет ничего устанавливать. У нас в новой системе отсутствует папка с ключами <strong><i>/etc/pacman.d/gnupg</i></strong>. Можно было скопировать её из системы-хоста, а можно просто скачать новые:</p>

<pre><code class="language-bash"># Ставим самую актуальную версию archlinux-keyring:
pacman -Sy archlinux-keyring

# Создаём локальнюу GnuPG-базу pacman (/etc/pacman.d/gnupg/) ...
# ... и переносим в неё ключи из archlinux-keyring:
pacman-key --init
pacman-key --populate archlinux

# И теперь можно сделать безопасное обновление системы:
pacman -Syu
</code></pre>

<p>Теперь у <strong><i>pacman</i></strong> есть всё необходимое, чтобы он мог устанавливать пакеты в новую систему.</p>

<pre><code class="language-bash">
# в новой системе нам понадобится текстовый редактор и интернет – базовый минимум:
pacman -Syu nano dhcpcd
</code></pre>

<h2>8. GRUB</h2>

<pre><code class="language-bash"># скачиваем пакеты grub и efibootmgr:
pacman -S grub efibootmgr

# ставим grub в систему:
grub-install \
   --target=x86_64-efi \
   --efi-directory=/boot/efi \
   --bootloader-id=Arch

# После этого появляется файл:
   # /boot/efi/EFI/Arch/grubx64.efi
# А также папка:
   # /boot/grub/ ...
   #     fonts
   #     grubenv
   #     locale
   #     themes
   #     x86_64-efi

# А также запись в NVRAM с помощью efibootmgr – что-то типа:
   # Boot0003*   Arch    HD(1,GPT,c78dfcd4-7bae-...)/\EFI\Arch\grubx64.efi
</code></pre>

<p>То есть после установки появляется файл <i><strong>/boot/efi/EFI/Arch/grubx64.efi</strong></i>, а также папка <strong><i>/boot/grub/</i></strong>.</p>
<p><strong><i>grubx64.efi</i></strong> – это основной загрузчик для UEFI. То есть, это исполняемый файл, который запускает прошивка UEFI.</p>
<p><strong><i>/boot/grub/</i></strong> – это рабочая директория GRUB с его «второй стадей». Отсюда GRUB загружает модули, здесь читает конфигурационный файл grub.cfg.</p>
<p>Всё это вынесено в разные места, потому что ESP – это специальный FAT-раздел, который должна распознать прошивка UEFI. А <strong><i>/boot/grub/</i></strong> – это обычная часть файловой системы Linux (ext4, например), где удобней хранить тяжёлые файлы GRUB.</p>

<p>Посмотреть запись в NVRAM, которую создал <strong><i>grub-install</i></strong>:</p>
<pre><code class="language-bash">efibootmgr</code></pre>

<p>И создаём конфигурационный файл:</p>
<pre><code class="language-bash">grub-mkconfig -o /boot/grub/grub.cfg</code></pre>

<h3>Установить fallback-загрузчик</h3>

<p>Может такое случиться, что после перезагрузки компьютера, UEFI не видит загрузчик, который мы установили чуть раньше, и Arch не может загрузиться. Такое бывает, когда прошивка UEFI при перезагрузке системы затирает запись в NVRAM. Некоторые производители встраивают в прошивку вот такое поведение: затирать кастомные записи на неизвестные загрузчики. А в этой записи у нас как раз содержится ссылка на загрузчик, который мы установили, т.е. на <strong><i>/boot/efi/EFI/Arch/grubx64.efi</i></strong>. Запись затёрлась и UEFI не знает, где искать наш <strong><i>grubx64.efi</i></strong>.</p>
<p>Чтобы точно убедиться, что проблема именно в этом, загружаемся опять с LiveCD и с помощью <strong><i>efibootmgr</i></strong> проверяем осталась наша запись в NVRAM, или исчезла. Если исчезла, значит прошивка на нашей материнской плате вот так вот гадко себя ведёт – проблема именно в этом.</p>
<p>Если такое произошло, то бороться с этим можно следующим образом. Существует стандартный путь к файлу с дефолтным загрузчиком: <strong><i>EFI/BOOT/BOOTX64.EFI</i></strong>. Такой загрузчик называется Fallback-загрузчиком. Любая прошивка UEFI, если не смогла найти вообще никакого загрузчика, проверяет именно этот путь в EFI-разделе: <strong><i>EFI/BOOT/BOOTX64.EFI</i></strong>. И если такой файл существует, то UEFI его запускает. Поэтому всё, что нам нужно сделать – это перенести/скопировать файл <strong><i>/boot/efi/EFI/Arch/grubx64.efi</i></strong> в <strong><i>/boot/efi/EFI/BOOT/BOOTX64.EFI</i></strong>. Либо вручную, либо это делает автоматически <strong><i>grub-install</i></strong>, если ему передать аргумент <strong><i>--removable</i></strong>.</p>
<pre><code class="language-bash">grub-install \
   --target=x86_64-efi \
   --efi-directory=/boot/efi \
   --removable      ## создать fallback-загрузчик

# Эта команда не создаёт запись в NVRAM
# Она создаёт файл /boot/efi/EFI/BOOT/BOOTX64.EFI
# ... и ставит остальную часть GRUB в /boot/grub/

# Если мы дополнительно передадим флаг "--bootloader-id=Arch", то он проигнорируется:
# ... "--removable" несовместим с "--bootloader-id" – второй просто игнорируется.
</code></pre>

<p>Теперь можно ещё раз перезагружаться. На этот раз UEFI точно должен найти загрузчик и запустить его.</p>

<h2>mkinitcpio</h2>

<pre><code class="language-bash">mkinitcpio -P
</code></pre>

<p>Эта команда нужна только если я ставил ядро НЕ через pacman. Она нужна для генерации initramfs.</p>
<p>Если во время установки ядра /boot не был смонтирован, или был смонтирован некорректно, то тогда тоже надо будет пересобирать initramfs.</p>
<p>Если я обновлял <strong><i>/etc/mkinitcpio.conf</i></strong>, то тогда тоже нужно будет пересобрать initramfs.</p>

<h2>efibootmgr</h2>
<pre><code class="language-bash">

# Изменить порядок загрузки:
sudo efibootmgr -o 0001,0000,0002

# Удалить запись:
sudo  efibootmgr -b 0003 -B

# Добавить запись:
sudo efibootmgr -c -d /dev/sda1 1 1 -L "Arch" -l "\EFI\Arch\grubx64.efi"
</code></pre>

<h2>После установки</h2>

<h3>Пользователи</h3>

<pre><code class="language-bash"># Создаём пользователя:
useradd -m -G wheel -s /bin/bash mark
# или:
useradd --create-home --groups wheel --shell /bin/bash mark
   # -m = --create-home – создаёт домашнюю директорию в /home/
   # -G wheel – добавляет пользователя в группу wheel
   # -s /bin/bash – устанавливает оболочку входа, в данном случае – /bin/bash
      # По умолчанию может быть: /bin/sh, /usr/bin/zsh, /bin/nologin

# Задаём пароль для созданного пользователя:
passwd mark
</code></pre>

<h3>sudo</h3>
<pre><code class="language-bash">
pacman -S sudo
   # создался файл /etc/sudoers
# Открыть файл sudoers с помощью vi (по умолчанию):
visudo

# Открыть /etc/sudoers с помощью nano:
EDITOR=nano visudo

# Раскомментируем следующую строку:
%wheel ALL=(ALL:ALL) ALL
# Это разрешает всем пользователям в группе wheel использовать sudo

# Авторизуемся как mark:
su - mark

# И теперь мы можем пользоваться командой sudo:
sudo ls /
</code></pre>

<h3>Часовой пояс</h3>
<pre><code class="language-bash">

# Создаём часовой пояс:
sudo ln -sf /usr/share/zoneinfo/Europe/Moscow /etc/localtime

# Или:
timedatectl set-timezone Europe/Moscow

# Генерируем файл /etc/adjtime
hwclock --systohc
   # Эта команда предполагает, что аппаратные часы по умолчанию используют UTC.
   # А мы здесь копируем системное время (UTC+3) в аппаратные часы (System -> RTC)
   # Это делается, потому что при перезагрузке BIOS/UEFI может отдать системе аппаратное время (особенно, если отключён интернет)

# Системное время можно узнать с помощью:
date
</code></pre>

<p><strong><i>/etc/adjtime</i></strong> – это текстовый файл, который хранит служебные данные. Аппаратные часы никогда не идут идеально точно. Они могут спешить/отставать на одну-две секунды в сутки. <strong><i>hwclock</i></strong> следит за этим и записывает корректировку в этот файл.</p>
<p>Файл <strong><i>/etc/adjtime</i></strong> появляется после первого запуска одной из следующих команд:</p>
<pre><code class="language-bash">hwclock --systohc
hwclock --hctosys
hwclock --adjust
</code></pre>

<h3>Примечание про UTC и Local</h3>
<p>Строка "UTC" или "LOCAL" в файле /etc/adjtime определяет в каком формате хранятся аппаратные часы. Linux обычно использует UTC. Windows использует LOCAL. Если файл покажет LOCAL, система считает, что RTC хранит локальное время.</p>
<ul>
    <li>RTC – Real-Time Clock (аппаратные часы реального времени), это маленький чип на материнской плате.</li>
    <li>NTP – Network Time Protocol (сетевой протокол времени), специальный протокол, с помощью которого компьютер синхронизирует своё время через интернет с точными эталонными серверами.</li>
</ul>


<h2>репозитории</h2>

<pre><code class="language-bash">
# В файле /etc/pacman.conf раскомментируем блок:
[multilib]
include = /etc/pacman.d/mirrorlist

# А далее:
sudo pacman -Sy

</code></pre>

<h2>hostname</h2>
<pre><code class="language-bash"># /etc/hostname

Govnuter
</code></pre>

<h2>hosts</h2>
<pre><code class="language-bash"># /etc/hosts

127.0.0.1   localhost  my.localhost
::1         localhost  my.localhost
</code></pre>

<h2>DNS</h2>
<pre><code class="language-bash"># /etc/resolv.conf

# Generated by dhcpcd from enp2s0.dhcp, enp2s0.ra
# /etc/resolv.conf.head can replace this line
nameserver 192.168.1.1
nameserver fe80::1%enp2s0
# /etc/resolv.conf.tail can replace this line
</code></pre>


<script src="/assets/highlight/languages/bash.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>