<!DOCTYPE html>
<html lang="RU">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sway</title>
	<link rel="stylesheet" href="/assets/styles/style.css">
    <link rel="stylesheet" href="/assets/highlight/styles_custom/androidstudio.css">
</head>
<body>
<script src="/assets/highlight/highlight.min.js"></script>
<a href="/arch">Вернуться назад</a>

<h1>sway</h1>

<p>!!! Никогда не надо запускать SWAY (и любые другие WAYLAND-сессии) через sudo</p>
<h3>Установка Sway</h4>

<ul>
<li>Для запуска <strong><i>sway</i></strong> нам понадобится <strong><i>mesa</i></strong>. Без Mesa <strong><i>sway</i></strong> не запустится на обычной Linux-системе с <strong><i>Intel/AMD</i></strong> GPU. Mesa – это реализация OpenGL для Linux/Unix.</li>
<li>Также нам понадобится терминал <strong><i>foot</i></strong>. По умолчанию конфигурационный файл sway настроен именно на запуск <strong><i>foot</i></strong> сочетанием клавиш Win+Enter. Если <strong><i>foot</i></strong> не установить, то мы не сможем зайти в терминал.</li>
</ul>
<p><strong><i>wlroots</i></strong> (отдельно ставить не надо) – это библиотека для Wayland-композиторов (Sway, Wayfire etc.). Она управляет мониторами, окнами, вводом с клавиатуры и мыши, рендерингом через OpenGL. Sway не напрямую работает с GPU — он использует wlroots, а wlroots уже использует OpenGL (через Mesa) для отрисовки окон и эффектов.</p>

<pre><code class="language-bash"># минимальный минимум для запуска sway:
sudo pacman -S mesa sway foot

# Для запуска X11-программ:
sudo pacman -S xorg-xwayland
</code></pre>

<h2>Инструменты sway</h2>
<p>Вместе со sway ставятся также и утилиты-помощники:</p>
<ul>
	<li>swaymsg</li>
	<li>swaynag</li>
</ul>


<h2>Запуск</h2>
<pre><code> dbus-run-session -- sway
 dbus-run-session sway
 dbus-run-session sway > ~/.sway.log 2>&1
 exec sway</code></pre>


<p>Sway запустился. Единственное, что отображается на экране по умолчанию – это <strong><i>swaybar</i></strong> наверху. <strong><i>Swaybar</i></strong> – это встроенная панель, входящая в состав самого пакета sway. Настроить её можно в конфигурационном файле sway, в  разделе <strong><i>bar</i></strong>.</p>

<h4>Основные команды управления sway:</h4>
<pre><code class="language-bash"># Win+Enter – Открыть окно терминала
swaymsg kill     # Win+Shift+Q – закрыть окно
swaymsg exit     # Win+Shift+E – выйти из sway (нужно будет подтвердить, кликнув мышкой)
swaymsg reload   # Win+Shift+C – перезагрузка конфигурации без выхода из сессии
</code></pre>
<p>Первое, что бросается мне в глаза – это мелкий шрифт в терминале. Чтобы его поменять пишем в конфигурационный файл foot:</p>
<pre><code class="language-ini"># ~/.config/foot/foot.ini

[main]
font=monospace:size=14      # увеличиваем шрифт с 8 до 14
dpi-aware=yes
</code></pre>
<pre><code class="language-bash"># Можно скопировать шаблон конфига:

cp /etc/xdg/foot/foot.ini ~/.config/foot/foot.ini
</code></pre>





<h2>Конфигурационный файл SWAY</h2>

<p>Конфигурационный файл находится здесь: <strong><i>/etc/sway/config</i></strong>. Скопируем его в домашнюю директорию:</p>

<pre><code class="language-bash">mkdir -p ~/.config/sway
cp /etc/sway/config ~/.config/sway/</code></pre>

<p>Первое, что следует сделать для удобства – это добавить русскую раскладку и Compose-key:</p>
<pre><code># Раскладка клавиатуры: английская и русская,
# смена языка – на Alt+Shift:
input * {
   xkb_layout us,ru
   xkb_options grp:alt_shift_toggle
}

# То же, но добавим ещё Compose-key на правый Alt:
input * {
   xkb_layout us,ru
   xkb_options grp:alt_shift_toggle,compose:ralt
}

# grp:alt_shift_toggle — это переключение раскладки Alt+Shift
# compose:ralt — это назначение правого Alt как Compose-клавиши
</code></pre>

<p>Вместе со <strong><i>sway</i></strong> у нас ещё загрузились в систему несколько обоев для рабочего стола – в папку <strong><i>/usr/share/backgrounds/sway/</i></strong>. А в config'е можно найти вот такую строку:</p>
<pre><code>output * bg /usr/share/backgrounds/sway/Sway_Wallpaper_Blue_1920x1080.png fill
</code></pre>
<p>Это означает, что файл <strong><i>Sway_Wallpaper_Blue_1920x1080.png</i></strong> должен отображаться в качестве фона рабочего стола. Но у нас рабочий стол чёрный. А всё потому, что эта команда в конфиге "под капотом" использует программу <strong><i>swaybg</i></strong> для того, чтобы установить обои. То есть <strong><i>swaybg</i></strong> у нас не установлен, но в дефолтном конфиге уже есть включённая настройка, которая использует <strong><i>swaybg</i></strong> для того, чтобы вывести на рабочий стол обои <strong><i>Sway_Wallpaper_Blue_1920x1080.png</i></strong>. Более того, если мы выйдем в TTY, то увидим что-то типа:</p>
<pre><code class="lagnuage-bash">00:00:00.356 [sway/config.c:1083] failed to execute 'swaybg' (background configuration probably not applied): No such file or directory
</code></pre>

<p>А это значит, что дефолтные обои у нас уже настроены, но пока не установлен <strong><i>swaybg</i></strong>. Из-за этого обои и не отображаются. Поэтому просто устанавливаем <strong><i>swaybg</i></strong> и перезагружаем конфиг: Win+Shift+C. Всё. Обои подгрузились.</p>




<h3>РАЗРЕШЕНИЕ И ЧАСТОТА</h3>
	
		
<pre><code class="language-bash"># Посмотретьтекущие настройки:
   swaymsg -t get_outputs
      # выведет допустимые разрешения и частоты
# или:
   wayland-info	## пакет wayland-utils
# или:
   wlr-randr		## wlr-randr

# Чтобы поменять разрешение и частоту навсегда, надо внести эту строку в ~/.config/sway/config:
   swaymsg output HDMI-A-2 mode 1920x1080@144Hz
</code></pre>
		
<h4>Чтобы поменять разрешение и частоту навсегда, надо внести эту строку в ~/.config/sway/config:</h4>
<pre><code>output HDMI-A-2 mode 1920x1080@144Hz</code></pre>
	

<h2>Переменные среды</h2>
<ul>
	<li>XDG_CURRENT_DESKTOP: sway</li>
	<li>XDG_SESSION_TYPE: wayland (значение по умолчанию)</li>
	<li>WAYLAND_DISPLAY: wayland-1 (значение по умолчанию)</li>
	<li>DISPLAY: :0 (значение по умолчанию)</li>
</ul>

<h2>Лаунчер</h2>
<p>Чтобы можно было удобно запускать приложения:</p>
<pre><code class="language-bash">sudo pacman -S wofi

# И создаём конфиг:
mkdir -p ~/.config/wofi
</code></pre>

<p>Запуск wofi:</p>
<pre><code class="language-bash">wofi --show drun

# или:
wofi --show run
</code></pre>

<p>В конфиге запуск лаунчера уже назначен на сочетание клавиш <strong><i>Win+D</i></strong>. По умолчанию там указан лаунчер <strong><i>wmenu-run</i></strong>. Просто закомментируем его и назначим наш <strong><i>wofi</i></strong>.</p>
<pre><code class="language-bash"># Your preferred application launcher
# set $menu wmenu-run
set $menu wofi --show drun

# Start your launcher
bindsym --to-code  $mod+d exec $menu
</code></pre>

<h2>wlogout</h2>
<p>AUR. Для работы необходим <strong><i>xwayland</i></strong>.</p>
<p>Чтобы можно было нормально выходить из системы.</p>
<p>При этом у меня по умолчанию не создался .desktop-файл в <strong><i>/usr/share/applications</i></strong>, поэтому <strong><i>wofi</i></strong> не запускает <strong><i>wlogout</i></strong>. Создадим сами wlogout.desktop в <strong></i>~/.local/share/applications</i></strong>.</p>

<pre><code class="language-ini">[Desktop Entry]
Type=Application
Name=wlogout
Exec=wlogout
Terminal=false
</code></pre>
<p>И обновим кэш:</p>
<pre><code class="language-bash">update-desktop-database ~/.local/share/applications
</code></pre>

<h2>Текстовый редактор</h2>

<p>Например, <strong><i>Featherpad</i></strong>.</p>

<h2>Браузер</h2>
<p>Теперь неплохо бы установить браузер, чтобы можно было выходить в интернет. Firefox вроде бы как нативно поддерживает wayland.</p>
<pre><code class="language-bash">sudo pacman -S firefox
</code></pre>

<h2>Файловый менеджер</h2>
<ul>
   <li>thunar</li>
   <li>pcmanfm</li>
</ul>

<h2>ntfs-3g</h2>
<p>Понадобится, если планируем подключать диски с файловой системой NTFS.</p>

<h2>Видео-проигрыватель</h2>
<p>mpv – и вот тут уже пригодится VAAPI (intel-media-driver, libva-utils)</p>

<p>Чтобы проверить, установлен VAAPI, или нет, сначала поставим libva-utils:</p>
<pre><code class="language-bash">sudo pacman -S libva-utils

# И запустим:
vainfo
</code></pre>
<p>Если VA-API работает — увидим что-то вроде «VA-API version: …», список поддерживаемых кодеков и драйвер. Если команда выдаёт ошибку ("cannot open driver", "va_openDriver failed" и т.п.), значит либо драйвер не установлен/не подходит, либо конфигурация не позволяет VA-API работать.</p>

<p>Если intel-media-driver не установлен, тогда ставим его:</p>
<pre><code class="language-bash">sudo pacman -S intel-media-driver

# И опять проверяем:
vainfo
</code></pre>

<p>Установим mpv:</p>
<pre><code class="language-bash">sudo pacman -S mpv
</code></pre>

<p>Чтобы проверить, использует ли mpv аппаратное декодирование, запустим видео файл:</p>
<pre><code class="language-bash">mpv --hwdec=vaapi --vo=gpu --gpu-context=wayland some_video.mkv

  # ...
  # Using hardware decoding (vaapi).
  # AO: [pipewire] 48000Hz stereo 2ch floatp
  # VO: [gpu] 1024x576 vaapi[nv12]
  # AV: 00:00:38 / 01:20:45 (1%) A-V:  0.000 Cache: 598s/150MB
</code></pre>
<p>Здесь мы видим строку: <i>Using hardware decoding (vaapi)</i>. Значит, аппаратное декодирование работает.</p>

<p>Если мы хотим получить больше информации, например, узнать используется wayland или xwayland, то можно запустить команду вот так:</p>
<pre><code class="language-bash">mpv --hwdec=vaapi --vo=gpu --gpu-context=wayland --msg-level=vo=v some_video.mkv
</code></pre>
<ul>
   <li>--hwdec=vaapig – включить аппаратное ускорение</li>
   <li>--vo=gpu – в качестве Video Output исользовать OpenGL/Vulkan</li>
   <li>--gpu-context=wayland – использовать в качестве контекста wayland</li>
</ul>

<p>Чтобы все эти опции запускались, когда мы кликаем по файлу, нужно прописать их в конфиг:</p>
<pre><code class="language-bash"># ~/.config/mpv/mpv.conf

hwdec=vaapi
vo=gpu
gpu-context=wayland
</code></pre>
<p>Теперь можно просто запускать файл командой:</p>
<pre><code class="language-bash">mpv filename.mkv
</code></pre>

<p>ГПТ посоветовал такой конфиг для макс. качества изображения:</p>
<pre><code class="language-bash">hwdec=vaapi
vo=gpu
gpu-context=wayland
profile=gpu-hq
scale=ewa_lanczossharp
cscale=ewa_lanczossharp
dscale=mitchell
video-sync=display-resample
interpolation
tscale=oversample
</code></pre>

<h2>Аудио-проигрыватель</h2>
<p>И тут придётся разобраться с ALSA, PipeWire... pavucontrol</p>

<h2>Громкость</h2>
<p>Чтобы можно было регулировать громкость звука в системе, поставим <strong><i>pavucontrol</i></strong>:</p>
<pre><code class="language-bash">sudo pacman -S pavucontrol
</code></pre>

<h2>Изображения</h2>
<p style="margin-bottom: 6px">Ставим прогрмму <strong><i>imv</i></strong> или <strong><i>feh</i></strong>.</p>
<pre style="margin-top: 6px"><code class="language-bash">sudo pacman -S imv

# для того, чтобы смотреть характеристики изображения:
sudo pacman -S imagemagick

# Теперь можно открыть изображение:
imv images/screenshot.png

# Или посмотреть его характеристики:
identify images/screenshot.png
</code></pre>

<h2>swaybar – раскладка</h2>
<p>По умолчанию в waybar'е отображается только год, месяц, дата и текущее время. За этот вывод в конфиге отвечает вот этот блок:</p>

<pre><code class="language-bash">#
# Status Bar:
#
# Read `man 5 sway-bar` for more information about this section.
bar {
    position bottom

    # When the status_command prints a new line to stdout, swaybar updates.
    # The default just shows the current date and time.
    status_command while date +'%Y-%m-%d %X'; do sleep 1; done

    colors {
        statusline #ffffff
        background #323232
        inactive_workspace #32323200 #32323200 #5c5c5c
    }
}
</code></pre>

<p>Всю работу здесь выполняет эта строка:</p>
<pre><code class="language-bash">status_command while date +'%Y-%m-%d %X'; do sleep 1; done
</code></pre>

<p>Создадим файл ~/.config/sway/status.sh:</p>
<pre><code class="language-bash">#!/bin/bash

while true; do
    # Получаем раскладку
    layout=$(swaymsg -t get_inputs | jq -r '.[] | select(.type=="keyboard") | .xkb_active_layout_name' | head -n 1)

    # Преобразуем в RU/EN
    case "$layout" in
        "Russian") layout="RU" ;;
        "English (US)") layout="EN" ;;
    esac

    # Вывод строки в бар
    echo "$layout | $(date +'%Y-%m-%d %H:%M:%S')"

    sleep 1
done
</code></pre>

<p>Сделаем этот файл исполняемым:</p>
<pre><code class="language-bash">chmod +x ~/.config/sway/status.sh
</code></pre>

<p>И теперь заменим <strong><i>status_command</i></strong> в конфиге на:</p>
<pre><code class="language-bash">status_command ~/.config/sway/status.sh
</code></pre>

<p>А ещё мне не нравится чисто белый цвет текста в статус-баре. Мне больше нравится цвет: #BAC3BC.</p>

<pre><code class="language-bash">
bar {
   ...
   colors {
      statusline #bac3bc
      ...
   }
}
</code></pre>

<p>Осталось перезагрузить конфиг sway (Mod+Shift+C) и в панели появится обозначение текущей раскладки.</p>


<h2>waybar</h2>
<pre><code class="language-bash">
## Запуск waybar:
   exec_always "pgrep -x waybar || waybar"
   # И надо обязательно закомментировать блок "bar", который отвечает за запуск swaybar, иначе при старте запустится дефолтный swaybar
</code></pre>	


<h3>swaylock и swayidle</h3>

<pre><code class="language-bash"># Устанавливаем их:

sudo pacman -S swaylock swayidle

# Запустить блокировщик с тёмным фоном:
swaylock -c 222222

#
swayidle -w \
   timeout 300 'swaylock -c 222222' \
   timeout 600 'swaymsg "output * dpms off"' \
      resume 'swaymsg "output * dpms on"'
</code></pre>

<ul>
   <li>-w – wait – не форкается в фон, а висит на переднем плане</li>
   <li>swaymsg "output * dpms off" – выключить мониторы по DPMS (экран гаснет, как будто ушёл спать)</li>
   <li>swaymsg "output * dpms on" – включить мониторы обратно</li>
   <li>timeout 300 'команда' – выполнять команду по истечении 300 секунд</li>
   <li>resume – привязан к timeout 600 – запускать команду при любом вводе (движение мыши, нажатие клавиши)</li>
</ul>

<p>Можно просто добавить команду запуска <strong><i>swayidle</i></strong> в конфиг <strong><i>sway</i></strong>:</p>
<pre><code class="language-bash"># ~/.config/sway/config

exec swayidle -w \
   timeout 300 'swaylock -c 222222' \
   timeout 600 'swaymsg "output * dpms off"' \
      resume 'swaymsg "output * dpms on"'
</code></pre>

<pre><code class="language-bash"># Получаю такое вот странное предупреждение, хотя всё работет:

swayidle -w timeout 10 'swaylock -c 222222'
  # 2025-12-03 00:35:36 - [Line 277] Failed to parse get BlockInhibited property: Invalid argument
</code></pre>

<p>Строка означает: «не получилось корректно прочитать свойство BlockInhibited у logind, но идём дальше». Предупреждение полность безопасное. У swayidle есть логика общения с org.freedesktop.login1 через D-Bus. Причём включает она это автоматически, если login1 присутствует (как раз как у меня).</p>

<p style="margin-bottom: 6px">Проверка свойства BlockInhibited:</p>
<pre style="margin-top: 6px"><code class="language-bash">busctl introspect org.freedesktop.login1 /org/freedesktop/login1 | grep BlockInhibited
  # .BlockInhibited    property  s    ""   emits-change
</code></pre>

<ul>
   <li>"" – пустая строка означает, что сейчас ничего не блокирует idle/sleep (ни плееры, ни другие программы)</li>
   <li>emits-change — logind шлёт сигнал, если значение меняется</li>
</ul>

<p>Посмотреть список ингибиторов:</p>
<pre><code class="language-bash">systemd-inhibit --list
</code></pre>
	
<pre><code class="language-bash"># Запускаем:
systemd-inhibit --what=idle sleep 10

# И проверяем ингибиторы:
systemd-inhibit --list
</code></pre>

<h2>Что дальше</h2>
<ul>
   <li>mako – уведомления</li>
   <li>grim – скриншоты</li>
   <li>slurp – выделение</li>
   <li>wl-clipboard – копирование в буфер обмена</li>
   <li>imagemagick – пипетка</li>
   <li>tesseract – OCR</li>
</ul>

<h2>Уведомления</h2>

<p style="margin-bottom: 6px">Для вывода уведомлений на экран установим <strong>mako</strong>:</p>
<pre style="margin-top: 6px"><code class="language-bash">sudo pacman -S mako
</code></pre>

<p style="margin-bottom: 6px">Проверить работу <strong>mako</strong> можно вот так:</p>
<pre style="margin-top: 6px; margin-bottom: 6px"><code class="language-bash">notify-send "Заголовок" "А содержание самого сообщения."
</code></pre>
<p style="margin-top: 6px">В правом верхнем углу должно появиться сообщение. Чтобы его убрать нужно кликнуть по нему мышкой.</p>

<p style="margin-bottom: 6px">Закрыть сообщение:</p>
<pre style="margin-top: 6px; margin-bottom: 6px"><code class="language-bash"># Закрыть текущее сообощение:
makoctl dismiss

# Закрыть все сообощения:
mako dismiss --all
</code></pre>

<p><a href="/arch/mako.html">Подробнее о mako</a></p>


<h2>Скриншоты</h2>

<p style="margin-bottom: 6px">Скриншоты экрана делаются с помощью <strong>grim</strong>:</p>
<pre style="margin-top: 6px"><code class="language-bash">sudo pacman -S grim
</code></pre>

<p style="margin-bottom: 6px">Сделаем скриншот экрана:</p>
<pre style="margin-top: 6px"><code class="language-bash">grim filename.png
</code></pre>

<p style="margin-bottom: 6px">Создадим уникальное имя для скриншота с датой и временем:</p>
<pre style="margin-top: 6px"><code class="language-bash">grim ~/Pictures/screenshot_$(date +%Y-%m-%d_%H-%M-%S-%3N).png
</code></pre>

<p style="margin-bottom: 6px">Частая практика в скриптах:</p>
<pre style="margin-top: 6px"><code class="language-bash"># Сначала присваиваем переменной путь к файлу:
FILE=~/Pictures/screenshot_$(date +%Y-%m-%d_%H-%M-%S-%3N).png
grim "$FILE"
</code></pre>

<p style="margin-bottom: 6px">А теперь всё это можно запихнуть в конфиг sway и назначить горячую клавишу:</p>
<pre style="margin-top: 6px; margin-bottom: 6px"><code class="language-bash"># ~/.config/sway/config
	
bindsym --to-code $mod+Print exec sh -c 'file=~/Pictures/screenshot-$(date +%Y-%m-%d_%H-%M-%S-%3N).png; grim "$file" && notify-send "Скриншот" "Сохранён в $file"'
</code></pre>
<p style="margin-top: 6px">Теперь сочетание клавиш <strong><i>Win+PrintScreen</i></strong> будет создавать скриншот всего экрана и сохранять его в png-файл в папку <strong><i>~/Pictures/</i></strong>.</p>


<h2>slurp</h2>

<p><strong>slurp</strong> работает через протокол <strong>wlroots</strong>. Для работы ему нужно фокусное приложение или композитор, который позволяет ему рисовать рамку выделения.</p>
<pre style="margin-top: 6px"><code class="language-bash">sudo pacman -S slurp
</code></pre>

<p style="margin-bottom: 6px">Если запустить <strong>slurp</strong> без параметров, то по умолчанию применяется параметр <strong><i>-d</i></strong> (те есть выделить область):</p>
<pre style="margin-top: 6px; margin-bottom: 6px"><code class="language-bash">slurp

# То же самое:
slurp -d

# Выделить один пиксель:
slurp -p
</code></pre>
<p style="margin-top: 6px">После того, как мы выбрали область, или кликнули по пикселю, то в терминал выводится либо координаты выбранной области, либо координата одного пикселя.</p>

<p style="margin-bottom: 6px">А теперь объединим grim и slurp – чтобы вывести скриншот определённой области на экране:</p>
<pre style="margin-top: 6px"><code class="language-bash">grim -g "$(slurp -d)" ~/Pictures/screenshot_$(date +%Y-%m-%d_%H-%M-%S-%3N).png

# Или с переменной:
FILE=~/Pictures/screenshot_$(date +%Y-%m-%d_%H-%M-%S-%3N).png
grim -g "$(slurp)" "$FILE"
</code></pre>

<p style="margin-bottom: 6px">А теперь всё это запихнём в конфиг <strong>Sway</strong> и назначим сочетание клавиш: <strong><i>Win+Shift+PrintScreen</i></strong>:</p>
<pre style="margin-top: 6px"><code class="language-bash"># ~/.config/sway/config
	
bindsym --to-code $mod+Shift+Print exec sh -c 'FILE=~/Pictures/screenshot_$(date +%Y-%m-%d_%H-%M-%S-%3N).png; grim -g "$(slurp)" "$FILE" && notify-send "Скриншот" "Сохранён в $file"'
</code></pre>


<h2>Пипетка</h2>

<p style="margin-bottom: 6px">Здесь нам поможет <strong>imagemagick</strong>:</p>
<pre style="margin-top: 6px"><code class="language-bash">sudo pacman -S imagemagick
</code></pre>

<p style="margin-bottom: 6px">Чтобы скопировать цвет в буфер обмена нам также понадобится <strong>wl-clipboard</strong>.</p>
<p style="margin-top: 6px"><a href="/arch/clipboard.html">Подробней про wl-clipboard</a>.</p>

<p style="margin-bottom: 6px">Создадим скрипт <strong><i>~/scripts/pipette.sh</i></strong>, который будет определять цвет пикселя, по которому мы кликнули, копировать в буфер обмена его HEX и выводить в mako:</p>
<pre style="margin-top: 6px"><code class="language-bash">#!/usr/bin/env bash

# Делаем скрин выделенной области
COLOR=$(grim -g "$(slurp -p)" -t ppm - | magick - txt:- | grep -m1 -oP '#\w{6}')

# Если пользователь нажал Esc и цвет не выбран
[ -z "$COLOR" ] && exit 0

# Копируем цвет в буфер обмена
echo -n "$COLOR" | wl-copy

# Создаем маленькую цветную иконку 64x64 для уведомления
magick -size 64x64 xc:"$COLOR" /tmp/color.png

# Показываем уведомление
notify-send -i /tmp/color.png "Цвет скопирован" "$COLOR"
</code></pre>

<p style="margin-bottom: 6px">А теперь проверим рабочесть этого скрипта:</p>
<pre style="margin-top: 6px"><code class="language-bash">chmod +x ~/scripts/pipette.sh
~/scripts/pipette.sh
</code></pre>

<p style="margin-bottom: 6px">Если всё нормально, то добавим его в конфиг <strong>Sway</strong>. Привяжем к сочетанию клавиш <strong><i>Win+Shift+P</i></strong>:</p>
<pre style="margin-top: 6px"><code class="language-bash">bindsym --to-code $mod+Shift+p exec ~/scripts/pipette.sh
</code></pre>


<p style="margin-bottom: 6px"><code style="background-color: #161616; padding-left: 6px; padding-right: 6px">grim -g "$(slurp -p)" -t ppm -</code> → PPM в <strong>stdout</strong></p>
<ul style="margin-top: 6px">
   <li><code style="background-color: #161616; padding-left: 6px; padding-right: 6px">-t ppm</code> или <code style="background-color: #161616; padding-left: 6px; padding-right: 6px">--type ppm</code> – это тип (format) изображения, который <strong>grim</strong> должен выдать</li>
   <li>PPM = Portable Pixmap – это текстовый / бинарный формат изображения, очень простой</li>
   <li>Дефис в конце команды <code style="background-color: #161616">&nbsp-&nbsp</code> означает "stdout", то есть не сохранять файл на диск, а вывести результат в стандартный поток вывода (терминал или пайп).</li>
</ul>

<p style="margin-bottom: 6px"><code style="background-color: #161616; padding-left: 10px; padding-right: 10px">magick - txt:-</code> → превращает PPM в текст с цветами пикселей</p>
<ul style="margin-top: 6px">
   <li><strong>magick</strong> – это новая команда <strong>ImageMagick 7</strong>, заменяет старый <strong>convert</strong>. Позволяет обрабатывать изображения, конвертировать их, получать информацию о пикселях и т.д.</li>
   <li><code style="background-color: #161616; padding-left: 6px; padding-right: 6px">-</code> (первый дефис) – означает <strong>stdin</strong>, то есть читаем изображение из стандартного потока.</li>
   <li><code style="background-color: #161616; padding-left: 6px; padding-right: 6px">txt:</code> – это формат Text (текстовый), который <strong>ImageMagick</strong> умеет выдавать: каждый пиксель превращается в строку вида: <code style="background-color: #161616; padding-left: 6px; padding-right: 6px">0,0: (255, 0, 0)  #FF0000  srgb(255,0,0)</code></li>
   <li><code style="background-color: #161616; padding-left: 6px; padding-right: 6px">-</code> (второй дефис – после <code style="background-color: #161616; padding-left: 6px; padding-right: 6px">txt:</code>) – выводить текст в <strong>stdout</strong>, а не в файл.</li>
</ul>

<p><code style="background-color: #161616; padding-left: 6px; padding-right: 6px">grep -m1 -oP '#\w{6}</code> → берёт первый HEX-цвет #RRGGBB.</p>

<h2>Tesseract</h2>

<p><strong>Tesseract</strong> – это OCR-движок (Optical Character Recognition).</p>

<p style="margin-bottom: 6px">Устанавливаем его:</p>
<pre style="margin-top: 6px"><code class="language-bash">sudo pacman -S tesseract
</code></pre>

<p style="margin-bottom: 6px">И сразу же проверяем список доступных языков:</p>
<pre style="margin-top: 6px; margin-bottom: 6px"><code class="language-bash">tesseract --list-langs
  # List of available languages in "/usr/share/tessdata/" (2):
  # afr
  # osd
</code></pre>
<p style="margin-top: 6px">У меня доступны только африкаанс и <strong>osd</strong> — orientation & script detection (служебный, не для текста).</p>

<p style="margin-bottom: 6px">Установим английский и русский языки:</p>
<pre style="margin-top: 6px"><code class="language-bash">sudo pacman -S tesseract-data-eng tesseract-data-rus

# Также могут быть полезны:
  # tesseract-data-deu – немецкий
  # tesseract-data-fra – французский
</code></pre>

<p style="margin-bottom: 6px">Теперь можно протестировать распознавание языка:</p>
<pre style="margin-top: 6px; margin-bottom: 6px"><code class="language-bash">tesseract ~/Pictures/kakashka.png ~/Pictures/output

# с явным указанием языка:
tesseract ~/Pictures/kakashka.png ~/Pictures/output3 -l eng

# можно смешивать языки:
tesseract ~/Pictures/kakashka.png ~/Pictures/output3 -l eng+rus

# вевести результат в терминал:
tesseract ~/Pictures/kakashka.png stdout -l eng
</code></pre>
<p style="margin-top: 6px">Создался файл <strong><i>~/Pictures/output.txt</i></strong>. Обратите внимание, что <strong>tesseract</strong> автоматическ добавляет <strong><i>.txt</i></strong> к имени файлу.</p>

<p style="margin-bottom: 6px">А теперь выведем в терминал то, что захватили с экрана:</p>
<pre style="margin-top: 6px"><code class="language-bash">grim -g "$(slurp)" -t png - | tesseract stdin stdout -l eng
</code></pre>

<p style="margin-bottom: 6px">Создадим скрипт, который будет копировать всё, что мы захватили с экрана, в буфер обмена и выводить в <strong>mako</strong> сообщение:</p>
<pre style="margin-top: 6px"><code class="language-bash">#!/usr/bin/env bash

# Языки OCR (eng или eng+rus)
LANGS="eng+rus"

# Делаем скрин выделенной области и распознаём текст
TEXT=$(grim -g "$(slurp)" -t png - \
  | tesseract stdin stdout -l "$LANGS" 2>/dev/null)

# Если пользователь нажал Esc или текст пуст
[ -z "$TEXT" ] && exit 0

# Копируем в буфер
echo -n "$TEXT" | wl-copy

# Укорачиваем текст для уведомления
PREVIEW=$(echo "$TEXT" | head -n 5)

# Уведомление
notify-send "OCR: текст скопирован" "$PREVIEW"
</code></pre>

<p style="margin-bottom: 6px">Делаем скрипт исполняемым и запускаем:</p>
<pre style="margin-top: 6px"><code class="language-bash">chmod +x ~/scripts/ocr.sh
~/scripts/ocr.sh
</code></pre>

<p style="margin-bottom: 6px">Если всё в порядке, добавим его в конфиг <strong>Sway</strong>:</p>
<pre style="margin-top: 6px"><code class="language-bash"># ~/.config/sway/config

bindsym --to-code $mod+t ~/scripts/ocr.sh
</code></pre>


<p style="margin-bottom: 6px"></p>
<pre style="margin-top: 6px"><code class="language-bash">

</code></pre>




<script src="/assets/highlight/languages/bash.min.js"></script>
<script src="/assets/highlight/languages/ini.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>