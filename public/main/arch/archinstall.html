<!DOCTYPE html>
<html lang="RU">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <link rel="stylesheet" href="/assets/styles/style.css">
    <link rel="stylesheet" href="/assets/highlight/styles_custom/androidstudio.css">
</head>
<body>
<script src="/assets/highlight/highlight.min.js"></script>
<p><a href="/arch/">Вернуться назад</a></p>

<p>Переписываю index1.html</p>

<h1>Установка Arch</h1>


<h2>vconsole</h2>

<pre><code class="language-bash"># Файлы с раскладками:
/usr/share/kbd/keymaps/i386/qwerty/

# Файлы со шрифтами:
/usr/share/kbd/consolefonts/

# Посмотреть список раскладок:
localectl list-keymaps
# или:
ls /usr/share/kbd/keymaps/i386/qwerty/

# Загрузить русскую раскладку
loadkeys ru

# Загрузить обратно английскую раскладку:
loadkeys us

# Дефолтная раскладка:
loadkeys defkeymap

# Установить шрифт с поддержкой  русского языка:
setfont cyr-sun16

setfont LatArCyrHeb-16
setfont LatArCyrHeb-16+
setfont LatArCyrHeb-19
setfont latarcyrheb-sun16
setfont latarcyrheb-sun32
</code></pre>

<h4>Посмотреть, какой файл раскладки загружается</h4>
<pre><code class="language-bash"># Вывести первые 10 записей:
sudo loadkeys -v en 2>&1 | head -n 10
   # Загружается /usr/share/kbd/keymaps/pine/en.map.gz
   # переключение на linux-keys-bare
   # предполагается iso-8859-15 euro
   # код клавиши 1, таблица 0 = 27
   # ...

   # аргумент -v выводит инфу в std:err, поэтому нам надо перенаправить его в std:out
</code></pre>

<p>Пример конфигурационного файла:</p>
<pre><code class="language-bash"># /etc/vconsole.conf:

KEYMAP=ru
FONT=cyr-sun16
</code></pre>

<p>Или вот русская раскладка, которая переключается через ALT+SHIFT:</p>
<pre><code class="language-bash"># /etc/vconsole.conf:

KEYMAP=ruwin_alt_sh-UTF-8
FONT=cyr-sun16
</code></pre>

<p>Если мы хотим, чтобы конфигурационный файл применился, надо либо перезагрузить систему, либо выполнить:</p>
<pre><code class="language-bash">sudo systemctl restart systemd-vconsole-setup.service</code></pre>


<p>Когда мы выполняем команду <strong><i>loadkeys ru</i></strong>, это подгружает файл <strong><i>/usr/share/kbd/keymaps/i386/qwerty/ru.map.gz</i></strong></p>
<p><strong><i>loadkeys us</i></strong> подгружает <strong><i>/usr/share/kbd/keymaps/i386/qwerty/us.map.gz</i></strong>.</p>
<p><strong><i>loadkeys ruwin_alt_sh-UTF-8</i></strong> подгружает <strong><i>/usr/share/kbd/keymaps/i386/qwerty/ruwin_alt_sh-UTF-8</i></strong></p>

<p>А вот <strong><i>loadkeys en</i></strong> подгружает файл <strong><i>/usr/share/kbd/keymaps/pine/en.map.gz</i></strong>.</p>


<h2>Локаль</h2>

<pre><code class="language-bash">

/etc/locale.conf

# Текущие переменные окружения:
locale

# Список доступных локалей:
locale -a


# Установить локаль:
sudo localectl set-locale LANG=ru_RU.UTF-8
# Либо вручную вписать в /etc/locale.conf:
LANG=ru_RU.UTF-8

# Локаль ru_RU.UTF-8 хранится в 
# /usr/lib/locale/

locale-gen 
   # Все сгенерированные этой командой локали помещаются в один общий бинарный файл:
   # /usr/lib/locale/locale-archive
   # /usr/lib/locale/C.utf8 - папка с минимальной базовой локалью

/usr/share/i18n/ - здесь хранятся текстовые шаблоны для генерации бинарных файлов локалей
</code></pre>

<p>То есть:</p>
<ul>
    <li><strong><i>/etc/locale.gen</i></strong> - тут мы раскомментируем строку с локалью, которую хотим сгенерировать;</li>
    <li>Выполняем команду <strong><i>locale-gen</i></strong>, чтобы сгенерировать локаль;</li>
    <li>Бинарный файл <strong><i>/usr/lib/locale/locale-archive</i></strong> обновляется и сгенерированная локаль попадает в него;</li>
    <li>Убедиться, что сгенерированная нами локаль попала в файл <strong><i>locale-archive</i></strong> можно с помощью команды <strong><i>locale -a</i></strong>, которая отображает все доступные локали из <strong><i>locale-archive</i></strong>.</li>
    <li>Внутри файла <strong><i>/usr/lib/locale/locale-archive</i></strong> может содержаться много локалей, поэтому мы должны указать системе, какую мы хотим использовать. Делается это в файле <strong><i>/etc/locale.conf</i></strong>.</li>
</ul>


<h2>2. Разметка жёсткого диска</h2>

<p>Проверим режим загрузки, чтобы узнать у нас стоит BIOS или UEFI:</p>
<pre><code class="language-bash">cat /sys/firmware/efi/fw_platform_size
# Если исп. режим BIOS, то никакой инфы не вылезет. А если исп. UEFI, то получим либо 64, либо 32
</code></pre>

<p>Посмотреть типы таблицы существующих разделов (Partition Table Type):</p>
<pre><code class="language-bash"># Здесь столбец PTTYPE покажет тип:
lsblk -o NAME,SIZE,TYPE,PTTYPE /dev/sda

# Или вот так:
sudo fdisk -l /dev/sda
    # ...
    # Тип метки диска: gpt  // Disklabel type: dos

# Или:
sudo parted /dev/sda print
    # ...
    # Таблица разделов: gpt // Partition Table: gpt

# Или:
sudo blkid /dev/sda
    # /dev/sda: PTUUID="e3398c6a-9208-40eb-b2db-c4cbb82a8df7" PTTYPE="gpt"

# То же самое, но развёрнуто:
sudo blkid -s PTUUID -s PTTYPE /dev/sda
    # /dev/sda: PTUUID="e3398c6a-9208-40eb-b2db-c4cbb82a8df7" PTTYPE="gpt"

# Вывести только значение:
sudo blkid -s PTTYPE -o value /dev/sda
    # gpt
</code></pre>

<p>У меня SSD на 512 GB. Я хочу разбить его на 4 рездела:</p>
<ul>
    <li>UEFI – 1 GB</li>
    <li>swap – 16 GB</li>
    <li>root – 80 GB</li>
    <li>home – ≈415 GB</li>
</ul>

<h2>Форматирование</h2>
<pre><code class="language-bash"># Форматирование разделов:
mkfs.fat -F 32 /dev/sda1    # Форматируем в FAT32
   # mkfs.vfat /dev/sda1    # То же самое
mkswap /dev/sda2            # Создаём swap-раздел
mkfs.ext4 /dev/sda3         # Форматируем в ext4
mkfs.ext4 /dev/sda4         # Форматируем в ext4

# Форматирование и создание метки одновременно:
mkfs.fat -F 32 -n EFILABEL /dev/sda1    # Форматируем в FAT32
   # mkfs.vfat -n EFILABEL /dev/sda1    # То же самое
mkswap -L SwapLabel /dev/sda2           # Создаём swap-раздел
mkfs.ext4 -L RootLabel /dev/sda3        # Форматируем раздел в ext4
mkfs.ext4 -L HomeLabel /dev/sda4        # Форматируем раздел в ext4

# Создать метку для уже отформатированных разделов:
fatlabel /dev/sda1 NEWLABEL     # для FAT32
tune2fs -L NewLabel /dev/sda3   # для ext4
e2label /dev/sda4 NewLabel      # для ext4
mkswap -L NewLabel /dev/sda2    # для swap-раздела

</code></pre>

<h2>Монтирование файловой системы</h2>

<pre><code class="language-bash">

mount /dev/sda3 /mnt
mkdir -p /mnt/boot/efi
mount /dev/sda1 /mnt/boot/efi
mount /dev/sda4 /mnt/home


</code></pre>

<h2>ставим базовые пакеты</h2>

<pre><code class="language-bash"># базовые пакеты:
pacman -r /mnt -S base linux linux-firmware

# А также нам понадобятся:
pacman -r /mnt -S dhcpcd nano

# На оф. сайте Arch говорится, что pacstrap копирует файл /etc/pacman.d/mirrorlist в новую систему
# Поэтому, наверное, надо его скопировать вручную:
mkdir -p /mnt/etc/pacman.d
cp /etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist

cp /etc/pacman.conf /mnt/etc/pacman.conf

# Чтобы повторить аргумент -K из pacstrap ...
# ... Ещё нужно инициализировать ключи внутри новой системы:
arch-chroot /mnt pacman-key --init
arch-chroot /mnt pacman-key --populate archlinux

   # в новой системе папка /etc/pacman.d/gnupg пустая

   # pacman-key --init – Создаёт локальную криптографическую инфраструктуру
   # pacman-key --populate archlinux – Добавляет официальные ключи Arch Linux

# Можно просто скопировать ключи из живой системы:
cp -r /etc/pacman.d/gnupg /mnt/etc/pacman.d/

# Если система старая, то ключи могут быть устаревшими.
# Тогда их нужно будет обновить:
pacman-key --refresh-keys


# pacstrap -K именно копирует ключи
</code></pre>

<p>или через pacstrap:</p>
<pre><code class="language-bash">
pacstrap -K /mnt base linux linux-firmware

   # -K – keyring, хранилище криптографических ключей
   # Это хранилище находится здесь: /etc/pacman.d/gnupg

   # pubring.gpg — публичные ключи (разработчики Arch)
   # trustdb.gpg — уровень доверия ключам
   # private-keys-v1.d/ — приватные ключи системы
</code></pre>

<p>Помимо установки пакетов, pacstrap -K также:</p>
<ul>
   <li>копирует /etc/pacman.conf</li>
   <li>копирует /etc/pacman.d/mirrorlist</li>
   <li>создаёт /mnt/etc/pacman.d/gnupg</li>
   <li>самое главное: выполняет инициализацию ключей <strong><i>pacman</i></strong> в новой системе:
     <pre><code class="language-bash"> pacman-key --init
 pacman-key --populate archlinux</code></pre>
   </li>
</ul>

<h2>Настройка системы</h2>

<pre><code class="language-bash">genfstab -U /mnt >> /mnt/etc/fstab

# Или:
genfstab -L /mnt >> /mnt/etc/fstab
   # вместо UUID отображать Label

# genfstab - утилита, которая автоматически создаёт таблицу монтирования (fstab) для Linux-системы.
# Она сканирует смонтированные разделы (или корневую файловую систему, которую мы ей укажем)
# И запишет инфу о том, как монтировать наши разделы в файл, который мы укажем.
</code></pre>

<h2>chroot</h2>

<p>Примонтируем оставшуюся файловую систему, которая необходима для полноценной работы:</p>
<pre><code class="language-bash">mount -t proc /proc /mnt/proc
mount --make-rslave /proc /mnt/proc
mount --rbind /sys /mnt/sys
mount --make-rslave /sys /mnt/sys
mount --rbind /dev /mnt/dev
mount --make-rslave /dev /mnt/dev
mount --rbind /run /mnt/run
mount --make-rslave /run /mnt/run
cp /etc/resolv.conf /mnt/etc/resolv.conf

# заходим в систему:
chroot /mnt /bin/bash
# или:
chroot /mnt /usr/bin/bash
</code></pre>

<p>Либо можно сделать так:</p>

<pre><code class="language-bash">
arch-chroot /mnt
</code></pre>


<h2>Установка загрузчика</h2>


<pre><code class="language-bash">grub-install \
   --target=x86_64-efi \
   --efi-directory=/boot/efi \
   --bootloader-id=Arch

# После этого появляется файл:
   # /boot/efi/EFI/Arch/grubx64.efi
# А также папка:
   # /boot/grub/ ...
   #     fonts
   #     grubenv
   #     locale
   #     themes
   #     x86_64-efi

# А также запись в NVRAM с помощью efibootmgr – что-то типа:
   # Boot0003*   Arch    HD(1,GPT,c78dfcd4-7bae-...)/\EFI\Arch\grubx64.efi
</code></pre>


<p>То есть после установки появляется файл <i><strong>/boot/efi/EFI/Arch/grubx64.efi</strong></i>, а также папка <strong><i>/boot/grub/</i></strong>.</p>
<p><strong><i>grubx64.efi</i></strong> – это основной загрузчик для UEFI. То есть, это исполняемый файл, который запускает прошивка UEFI.</p>
<p><strong><i>/boot/grub/</i></strong> – это рабочая директория GRUB с его «второй стадей». Отсюда GRUB загружает модули, здесь читает конфигурационный файл grub.cfg.</p>
<p>Всё это вынесено в разные места, потому что ESP – это специальный FAT-раздел, который должна распознать прошивка UEFI. А <strong><i>/boot/grub/</i></strong> – это обычная часть файловой системы Linux (ext4, например), где удобней хранить тяжёлые файлы GRUB.</p>

<pre><code class="language-bash">grub-install \
   --target=x86_64-efi \
   --efi-directory=/boot/efi \
   --removable      ## помещает загрузчик GRUB в универсальное место

# Эта команда не создаёт запись в NVRAM
# Она создаёт файл /boot/efi/EFI/BOOT/BOOTX64.EFI
# ... и ставит остальную часть GRUB в /boot/grub/

# Если мы дополнительно передадим флаг "--bootloader-id=Arch", то он проигнорируется:
# ... "--removable" несовместим с "--bootloader-id" – второй просто игнорируется.
</code></pre>

<p>И создаём конфигурационный файл:</p>
<pre><code class="language-bash">grub-mkconfig -o /boot/grub/grub.cfg</code></pre>


<h2>mkinitcpio</h2>

<pre><code class="language-bash">mkinitcpio -P
</code></pre>

<p>Эта команда нужна только если я ставил ядро НЕ через pacman. Она нужна для генерации initramfs.</p>
<p>Если во время установки ядра /boot не был смонтирован, или был смонтирован некорректно, то тогда тоже надо будет пересобирать initramfs.</p>
<p>Если я обновлял <strong><i>/etc/mkinitcpio.conf</i></strong>, то тогда тоже нужно будет пересобрать initramfs.</p>

<h2>efibootmgr</h2>
<pre><code class="language-bash">

# Изменить порядок загрузки:
sudo efibootmgr -o 0001,0000,0002

# Удалить запись:
sudo  efibootmgr -b 0003 -B

# Добавить запись:
sudo efibootmgr -c -d /dev/sda1 1 1 -L "Arch" -l "\EFI\Arch\grubx64.efi"
</code></pre>

<p>Если прошивка UEFI не нашла запись в NVRAM с сылкой на загрузчик, то она ищет fallback-загрузчик. Fallback-загрузчик должен быть в системном разделе EFI (ESP) в <strong><i>EFI/BOOT/BOOTX64.EFI</i></strong>. UEF-прошивка ищет ESP по его GUID-типу, который должен быть: ESP (EFI System Partition) и он должен быть отформатирован в файловой системе FAT32. В моём случае ESP-раздел находится первым на SSD и примонтирован в <strong><i>/boot/efi</i></strong>. То есть, у меня fallback-загрузчик находится в <strong><i>/boot/efi/EFI/BOOT/BOOTX64.EFI</i></strong>. И соответственно, если UEFI-прошивка не найдёт записи в NVRAM, то она найдёт этот fallback-загрузчик.</p>


<h2>Пользователи</h2>

<pre><code class="language-bash"># Создаём пользователя:
useradd -m -G wheel -s /bin/bash mark
# или:
useradd --create-home --groups wheel --shell /bin/bash mark
   # -m = --create-home – создаёт домашнюю директорию в /home/
   # -G wheel – добавляет пользователя в группу wheel
   # -s /bin/bash – устанавливает оболочку входа, в данном случае – /bin/bash
      # По умолчанию может быть: /bin/sh, /usr/bin/zsh, /bin/nologin

# Задаём пароль для созданного пользователя:
passwd mark
</code></pre>

<h2>sudo</h2>
<pre><code class="language-bash">
pacman -S sudo
   # создался файл /etc/sudoers
# Открыть файл sudoers с помощью vi (по умолчанию):
visudo

# Открыть /etc/sudoers с помощью nano:
EDITOR=nano visudo

# Раскомментируем следующую строку:
%wheel ALL=(ALL:ALL) ALL
# Это разрешает всем пользователям в группе wheel использовать sudo

# Авторизуемся как mark:
su - mark

# И теперь мы можем пользоваться командой sudo:
sudo ls /
</code></pre>

<h2>Часовой пояс</h2>
<pre><code class="language-bash">

# Создаём часовой пояс:
sudo ln -sf /usr/share/zoneinfo/Europe/Moscow /etc/localtime

# Или:
timedatectl set-timezone Europe/Moscow

# Генерируем файл /etc/adjtime
hwclock --systohc
   # Эта команда предполагает, что аппаратные часы по умолчанию используют UTC.
   # А мы здесь копируем системное время (UTC+3) в аппаратные часы (System -> RTC)
   # Это делается, потому что при перезагрузке BIOS/UEFI может отдать системе аппаратное время (особенно, если отключён интернет)

# Системное время можно узнать с помощью:
date
</code></pre>

<p><strong><i>/etc/adjtime</i></strong> – это текстовый файл, который хранит служебные данные. Аппаратные часы никогда не идут идеально точно. Они могут спешить/отставать на одну-две секунды в сутки. <strong><i>hwclock</i></strong> следит за этим и записывает корректировку в этот файл.</p>
<p>Файл <strong><i>/etc/adjtime</i></strong> появляется после первого запуска одной из следующих команд:</p>
<pre><code class="language-bash">hwclock --systohc
hwclock --hctosys
hwclock --adjust
</code></pre>

<h3>Примечание про UTC и Local</h3>
<p>Строка "UTC" или "LOCAL" в файле /etc/adjtime определяет в каком формате хранятся аппаратные часы. Linux обычно использует UTC. Windows использует LOCAL. Если файл покажет LOCAL, система считает, что RTC хранит локальное время.</p>
<ul>
    <li>RTC – Real-Time Clock (аппаратные часы реального времени), это маленький чип на материнской плате.</li>
    <li>NTP – Network Time Protocol (сетевой протокол времени), специальный протокол, с помощью которого компьютер синхронизирует своё время через интернет с точными эталонными серверами.</li>
</ul>


<h2>репозитории</h2>

<pre><code class="language-bash">
# В файле /etc/pacman.conf раскомментируем блок:
[multilib]
include = /etc/pacman.d/mirrorlist

# А далее:
sudo pacman -Sy

</code></pre>

<h2>hostname</h2>
<pre><code class="language-bash"># /etc/hostname

Govnuter
</code></pre>

<h2>hosts</h2>
<pre><code class="language-bash"># /etc/hosts

127.0.0.1   localhost  my.localhost
::1         localhost  my.localhost
</code></pre>

<script src="/assets/highlight/languages/bash.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>